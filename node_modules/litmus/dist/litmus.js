
define('lib/utils',["require","exports","module"],function(require,exports,module){
/**
 * @function Make a constructor extend another.
 * Makes a subclass by creating a prototype for the child that shares the
 * prototype of the parent. Addionally sets the base property of the child
 * function to point to the parent function (useful for calling
 * `arguments.callee.base.apply(this, arguments)` in the top of the child
 * function to allow use of parent constructor).
 *
 * @param {Function} child
 *   Child constructor.
 * @param {Function} parent
 *   Parent constructor.
 */

exports.extend = function (child, parent) {
    var p = function () {};
    p.prototype = parent.prototype;
    child.prototype = new p();
    child.base = parent;
};

/**
 * @function Add methods for subscribing to and emitting events on a class.
 * @param {Function} protoClass
 *     prototype to add the methods onto.
 */

exports.makeEventEmitter = function (protoClass) {
    protoClass.prototype.on = function (eventName, callback, invocant) {
        if (! this._eventHandlers) {
            this._eventHandlers = {};
        }
        if (! this._eventHandlers[eventName]) {
            this._eventHandlers[eventName] = [];
        }
        this._eventHandlers[eventName].push(
            invocant ?
                function (e) { return callback.call(invocant, e); } :
                callback
        );
    };
    protoClass.prototype._fireEvent = function (eventName, event) {
        if (! event) {
            event = {};
        }
        event.attachedTo = this;
        if (! (this._eventHandlers && this._eventHandlers[eventName])) {
            return;
        }
        this._eventHandlers[eventName].map(function (handler) {
            handler(event);
        });
    };
}

/**
 * @function Check if an object was created by a constructor or an extention of it.
 * Sees if parameter is an instanceof the constructor or if it
 * is an instanceof a parent class, where parents are identified by following the `base`
 * property on each function (set by extend function).
 *
 * @param {Object} instance
 *   The object that we are testing the type of.
 * @param {Function} isType
 *   The constructor that we are testing the object's type against.
 *
 * @returns: A boolean indicating if object is correct type.
 */

var isa = exports.isa = function (instance, isType) {
    return (instance instanceof isType) ? true :
        isType.base ? isa(instance, isType.base) : false;
}

/**
 * @function: Repeat a string a number of times.
 *
 * @param {String} str
 *   The string to repeat.
 * @param {integer} times
 *   The number of times to repeat the string.
 *
 * @returns: The repeated string.
 */

exports.times = function (str, times) {
    var res = new Array(times);
    for (var i = 0; i < times; i++)
        res[i] = str;
    return res.join('');
}

/**
 * @function: Show the structure of a JavaScript value or object.
 *
 * @param {any} o
 *   The value or object to dump the structure of.
 *
 * @returns: A string similar to the Javascript that would be needed to create the value.
 */

var hop = function (o, i) {
    return Object.prototype.hasOwnProperty.call(o, i);
};

exports.dump = function (o, level) {
    if (! level) level = 0;
    if (level > 4) return '...';
    if (typeof(o) === 'undefined') return 'undefined';
    if (typeof(o) === 'number') return o;
    if (typeof(o) === 'function') return 'function () { ... }';
    if (typeof(o) === 'boolean') return o ? 'true' : 'false';
    if (typeof(o) === 'object' && o instanceof Array) {
        var r     = ['['],
            first = true;
        for (var i = 0, l = o.length; i < l; i++) {
            if (first) {
                first = false;
            }
            else {
                r.push(', ');
            }
            r.push(arguments.callee(o[i], level + 1));
        }
        r.push(']');
        return r.join('');
    }
    else if (o === null) {
        return 'null';
    }
    else if (typeof(o) === 'object') {
        var r      = ['{'],
            first  = true,
            sorted = Object.keys(o).sort();
        for (var i = 0, l = sorted.length; i < l; i++) {
            if (! hop(o, sorted[i])) {
                continue;
            }
            if (first) {
                first = false;
            }
            else {
                r.push(', ');
            }
            r.push("'", sorted[i], "' : ", arguments.callee(o[sorted[i]], level + 1));
        }
        r.push('}');
        return r.join('');
    }
    o = o.replace(/([\\\'])/g, '\\$1');
    return '\'' + o.replace(/\n/g, '\\n') + '\'';
}

/**
 * @function Get a string with whitespace removed.
 *
 * @param {String} str
 *   The string to return a stripped version of.
 *
 * @returns: A string copy of the input string with no whitespace.
 */

exports.stripWhitespace = function (str) {
    if (typeof(str) === 'undefined') return 'undefined';
    return String(str).replace(/\s+/g, ' ');
}

/**
 * @function Takes a base path and path and returns the latter relative to the former.
 * @param {String} base
 *     The base path
 * @param {String} path
 *     The path to make absolute (if it isn't already)
 * @returns: The absolute path
 */

exports.makeAbsolutePath = function (base, path) {
    if (/^\//.test(path)) {
        return path;
    }
    if (path === '.') {
        return base;
    }
    return base + '/' + path.replace(/^\.\//, '');
}

});
define('lib/assertions',["require","exports","module","./utils"],function(require,exports,module){
var utils = require('./utils');

/**
 * @abstract
 * @constructor Abstract base class for classes representing assertions that have been run.
 *
 * @param {String} message
 *    The message that identifies the assertion.
 */

var addAssertionTo = exports.addAssertionTo = function (to, name, run) {
    var Assertion = function () {};
    Assertion.prototype.isAssertion = true;
    Assertion.prototype.run = run;
    Assertion.prototype.setResult = function (message, passed, extra) {
        this.message = message;
        this.passed  = passed;
        this.failed  = ! passed;
        this.extra   = extra;
    };
    Assertion.prototype.toString = function () {
        return 'test.' + name + '(..., "' + this.message + '")';
    };
    to[name] = Assertion;
};

exports.builtins = {};

/**
 * @extends Assertion
 * @constructor The simplest type of successful assertion - one that always passes.
 *
 * @param {String} message
 *   The message that identifies the assertion.
 */

addAssertionTo(exports.builtins, 'pass', function (message) {
    this.setResult(message, true);
    return true;
});

/**
 * @extends Assertion
 * @constructor The simplest type of unsuccessful assertion - one that always fails.
 *
 * @param {String} message
 *   The message that identifies the assertion.
 */

addAssertionTo(exports.builtins, 'fail', function (message) {
    this.setResult(message, false);
    return false;
});

/**
 * @extends Assertion
 * @constructor Assertion that passes if a boolean value is true.
 *
 * @param {boolean} cond
 *   True if the assertion was successful.
 * @param {String} message
 *   The message that identifies the assertion.
 */

addAssertionTo(exports.builtins, 'ok', function (pass, message) {
    this.setResult(message, pass);
    return !! pass;
});

/**
 * @extends Assertion
 * @constructor Assertion that passes if a boolean value is false.
 *
 * @param {boolean} cond
 *   True if the assertion was unsuccessful.
 * @param {String} message
 *   The message that identifies the assertion.
 */

addAssertionTo(exports.builtins, 'nok', function (fail, message) {
    this.setResult(message, ! fail);
    return ! fail;
});

/**
 * @extends Assertion
 * @constructor Assertion that passes if a value equals (==) another value.
 *
 * @param {any} val
 *   Value being tested.
 * @param {any} isVal
 *   The value that val must equal.
 * @param {String} message
 *   The message that identifies the assertion.
 */

addAssertionTo(exports.builtins, 'is', function (val, isVal, message) {
    // keep this == instead of === as we want it to be permissive with types
    var passed = val == isVal || utils.dump(val, -10) === utils.dump(isVal, -10);
    var extra;
    if (! passed) { // TODO - quote and truncate
        extra = ['\n    expected: ', utils.dump(isVal), '\n         got: ', utils.dump(val)].join('');
    }
    this.setResult(message, passed, extra);
    return passed;
});

/**
 * @extends Assertion
 * @constructor Assertion that passes if a value does not equal (!=) another value.
 *
 * @param {any} val
 *   Value being tested.
 * @param {any} notVal
 *   The value that val must not equal.
 * @param {String} message
 *   The message that identifies the assertion.
 */

addAssertionTo(exports.builtins, 'not', function (val, notVal, message) {
    var passed = val != notVal;
    var extra;
    if (! passed) { // TODO - quote and truncate
        extra = "got '" + val + "', expecting something else";
    }
    this.setResult(message, passed, extra);
    return passed;
});

/**
 * @extends Assertion
 * @constructor Assertion that tests if an object is a member of a class. The assertion
 *              passes if the object was created using the function clss,
 *              or if it was created with any of the base classes (those that can be
 *              retrieved using the `base` property of the function and the `base` property
 *              of the resulting parent function and so on).
 *
 * @param {Object} instance 
 *   The object that is being tested for class membership.
 * @param {Function} clss
 *   The class that the object must be a member of.
 * @param {String} message
 *   The message that identifies the assertion.
 */

addAssertionTo(exports.builtins, 'isa', function (instance, clss, message) {
    var passed = clss && utils.isa(instance, clss);
    var extra = '';
    if (! passed) {
        if (typeof(instance) === 'undefined') {
            extra = '\n    instance is undefined';
        }
        else if (typeof(clss) === 'undefined') {
            extra = '\n    class is undefined';
        }
        else if (! passed) {
            extra = '\n    expected class: '
                  + utils.stripWhitespace(instance.constructor)
                  + '\n       found class: '
                  + utils.stripWhitespace(clss);
        }
    }
    this.setResult(message, passed, extra);
    return passed;
});

/**
 * @extends Assertion
 * @constructor Assertion that tests if a value is greater than another value.
 *
 * @param {String|Number} val
 *   The value that must be greater.
 * @param {String|Number} gtVal
 *   The value that val must be greater than.
 * @param {String} message
 *   The message that identifies the assertion.
 */

addAssertionTo(exports.builtins, 'gt', function (val, gtVal, message) {
    var passed = val > gtVal;
    var extra;
    if (! passed) {
        extra = "expected greater than '" + gtVal + "', got '" + val + "'";
    }
    this.setResult(message, passed, extra);
    return passed;
});

/**
 * @extends Assertion
 * @constructor Assertion that tests if a value is greater than or equal to another value.
 *
 * @param {String|Number} val
 *   The value that must be greater or equal.
 * @param {String|Number} gteVal
 *   The value that val must be greater than or equal to.
 * @param {String} message
 *   The message that identifies the assertion.
 */

addAssertionTo(exports.builtins, 'gte', function (val, gtVal, message) {
    var passed = val >= gtVal;
    var extra;
    if (! passed) {
        extra = "expected greater than or equal to '" + gtVal + "', got '" + val + "'";
    }
    this.setResult(message, passed, extra);
    return passed;
});

/**
 * @extends Assertion
 * @constructor Assertion that tests if a value is less than another value.
 *
 * @param {String|Number} val
 *   The value that must be less.
 * @param {String|Number}
 *   The value that val must be less than.
 * @param {String|Number} message
 *   The message that identifies the assertion.
 */

addAssertionTo(exports.builtins, 'lt', function (val, ltVal, message) {
    var passed = val < ltVal;
    var extra;
    if (! passed) {
        extra = "expected less than '" + ltVal + "', got '" + val + "'";
    }
    this.setResult(message, passed, extra);
    return passed;
});

/**
 * @extends Assertion
 * @constructor Assertion that tests if a value is less than or equal to another value.
 *
 * @param {String|Number} val
 *   The value that must be less or equal.
 * @param {String|Number} lteVal
 *   The value that val must be less than or equal to.
 * @param {String|Number} message
 *   The message that identifies the assertion.
 */

addAssertionTo(exports.builtins, 'lte', function (val, lteVal, message) {
    var passed = val <= lteVal;
    var extra;
    if (! passed) {
        extra = "expected less or equal to '" + lteVal + "', got '" + val + "'";
    }
    this.setResult(message, passed, extra);
    return passed;
});

/**
 * @extends Assertion
 * @constructor Assertion that tests if a value matches a regular expression.
 *
 * @param {String} val
 *   The value that will be matched.
 * @param {RegExp} re
 *   The regular expression to match against.
 * @param {String} message
 *   The message that identifies the assertion.
 */

addAssertionTo(exports.builtins, 'like', function (val, re, message) {
    var passed = re.test(val);
    var extra;
    if (! passed) {
        extra = "'" + val + "' does not match regular expression " + re;
    }
    this.setResult(message, passed, extra);
    return passed;
});

/**
 * @extends Assertion
 * @constructor Assertion that tests if a value does not match a regular expression.
 *
 * @param {String} val
 *   The value that will be matched.
 * @param {RegExp} re
 *   The regular expression to match against.
 * @param {String} message
 *   The message that identifies the assertion.
 */

addAssertionTo(exports.builtins, 'unlike', function (val, re, message) {
    var passed = ! re.test(val);
    var extra;
    if (! passed) {
        extra = "'" + val + "' does matches regular expression " + re;
    }
    this.setResult(message, passed, extra);
    return passed;
});

/**
 * @extends Assertion
 * @constructor Assertion that tests if a function raises an exception, and that exception
 *              matches a regular expression.
 *
 * @param {Function} func
 *   The function that will be executed.
 * @param {RegExp} re
 *   The regular expression to match the exception against.
 * @param {String} message
 *   The message that identifies the assertion.
 */

addAssertionTo(exports.builtins, 'throwsOk', function (func, re, message) {
    var passed = true, error, extra;
    try {
        func();
    }
    catch (e) {
        error = e;
    }
    if (! error) {
        passed = false;
        extra = 'no exception thrown';
    }
    else if (re) {
        var asString = error.toString ? error.toString() : error;
        passed = re.test(asString);
        if (! passed) {
            extra = 'exception "' + asString + '" does not match regular expression ' + re;
        }
    }
    this.setResult(message, passed, extra);
    return passed;
});


});
(function(define){
define('promised-io/promise',['require','exports','module'],function(require,exports){

// Kris Zyp

// this is based on the CommonJS spec for promises: 
// http://wiki.commonjs.org/wiki/Promises
// Includes convenience functions for promises, much of this is taken from Tyler Close's ref_send 
// and Kris Kowal's work on promises.
// // MIT License

// A typical usage:
// A default Promise constructor can be used to create a self-resolving deferred/promise:
// var Promise = require("promise").Promise;
//	var promise = new Promise();
// asyncOperation(function(){
//	Promise.resolve("succesful result");
// });
//	promise -> given to the consumer
//	
//	A consumer can use the promise
//	promise.then(function(result){
//		... when the action is complete this is executed ...
//	 },
//	 function(error){
//		... executed when the promise fails
//	});
//
// Alternately, a provider can create a deferred and resolve it when it completes an action. 
// The deferred object a promise object that provides a separation of consumer and producer to protect
// promises from being fulfilled by untrusted code.
// var defer = require("promise").defer;
//	var deferred = defer();
// asyncOperation(function(){
//	deferred.resolve("succesful result");
// });
//	deferred.promise -> given to the consumer
//	
//	Another way that a consumer can use the promise (using promise.then is also allowed)
// var when = require("promise").when;
// when(promise,function(result){
//		... when the action is complete this is executed ...
//	 },
//	 function(error){
//		... executed when the promise fails
//	});

exports.errorTimeout = 100;	
var freeze = Object.freeze || function(){};

/**
 * Default constructor that creates a self-resolving Promise. Not all promise implementations
 * need to use this constructor.
 */
var Promise = function(canceller){
};

/**
 * Promise implementations must provide a "then" function.
 */
Promise.prototype.then = function(resolvedCallback, errorCallback, progressCallback){
	throw new TypeError("The Promise base class is abstract, this function must be implemented by the Promise implementation");
};

/**
 * If an implementation of a promise supports a concurrency model that allows
 * execution to block until the promise is resolved, the wait function may be 
 * added. 
 */
/**
 * If an implementation of a promise can be cancelled, it may add this function
 */
 // Promise.prototype.cancel = function(){
 // };

Promise.prototype.get = function(propertyName){
	return this.then(function(value){
		return value[propertyName];
	});
};

Promise.prototype.put = function(propertyName, value){
	return this.then(function(object){
		return object[propertyName] = value;
	});
};

Promise.prototype.call = function(functionName /*, args */){
	return this.then(function(value){
		return value[functionName].apply(value, Array.prototype.slice.call(arguments, 1));
	});
};

/**
 * This can be used to conviently resolve a promise with auto-handling of errors:
 * setTimeout(deferred.resolverCallback(function(){
 *   return doSomething();
 * }), 100);
 */
Promise.prototype.resolverCallback = function(callback){
	var self = this;
	return function(){
		try{
			self.resolve(callback());
		}catch(e){
			self.reject(e);
		}
	}
};

/** Dojo/NodeJS methods*/
Promise.prototype.addCallback = function(callback){
	return this.then(callback);
};

Promise.prototype.addErrback = function(errback){
	return this.then(function(){}, errback);
};

/*Dojo methods*/
Promise.prototype.addBoth = function(callback){
	return this.then(callback, callback);
};

Promise.prototype.addCallbacks = function(callback, errback){
	return this.then(callback, errback);
};

/*NodeJS method*/
Promise.prototype.wait = function(){
	return exports.wait(this);
};

Deferred.prototype = Promise.prototype;
// A deferred provides an API for creating and resolving a promise.
exports.Promise = exports.Deferred = exports.defer = defer;
function defer(){
	return new Deferred();
} 

// this can be set to other values
exports.currentContext = null;

function Deferred(canceller){
	var result, finished, isError, waiting = [], handled;
	var promise = this.promise = new Promise();
	var context = exports.currentContext;
	
	function notifyAll(value){
		var previousContext = exports.currentContext;
		if(finished){
			throw new Error("This deferred has already been resolved");				
		}
		try{
			if(previousContext !== context){
				if(previousContext && previousContext.suspend){
					previousContext.suspend();
				}
				exports.currentContext = context;
				if(context && context.resume){
					context.resume();
				}
			}
			result = value;
			finished = true;
			for(var i = 0; i < waiting.length; i++){
				notify(waiting[i]);	
			}
		}
		finally{
			if(previousContext !== context){
				if(context && context.suspend){
					context.suspend();
				}
				if(previousContext && previousContext.resume){
					previousContext.resume();
				}
				exports.currentContext = previousContext;
			}
		}
	}
	function notify(listener){
		var func = (isError ? listener.error : listener.resolved);
		if(func){
			handled = true;
				try{
					var newResult = func(result);
					if(newResult && typeof newResult.then === "function"){
						newResult.then(listener.deferred.resolve, listener.deferred.reject);
						return;
					}
					listener.deferred.resolve(newResult);
				}
				catch(e){
					listener.deferred.reject(e);
				}
		}
		else{
			if(isError){
				if (listener.deferred.reject(result, true)) {
					handled = true;
					}
			}
			else{
				listener.deferred.resolve.call(listener.deferred, result);
			}
		}
	}
	// calling resolve will resolve the promise
	this.resolve = this.callback = this.emitSuccess = function(value){
		notifyAll(value);
	};
	
	// calling error will indicate that the promise failed
	var reject = this.reject = this.errback = this.emitError = function(error, dontThrow){
		isError = true;
		notifyAll(error);
		if (!dontThrow && typeof setTimeout !== "undefined") {
			setTimeout(function () {
				if (!handled) {
					throw error;
				}
			}, exports.errorTimeout);
		}
		return handled;
	};
	
	// call progress to provide updates on the progress on the completion of the promise
	this.progress = function(update){
		for(var i = 0; i < waiting.length; i++){
			var progress = waiting[i].progress;
			progress && progress(update);	
		}
	}
	// provide the implementation of the promise
	this.then = promise.then = function(resolvedCallback, errorCallback, progressCallback){
		var returnDeferred = new Deferred(promise.cancel);
		var listener = {resolved: resolvedCallback, error: errorCallback, progress: progressCallback, deferred: returnDeferred}; 
		if(finished){
			notify(listener);
		}
		else{
			waiting.push(listener);
		}
		return returnDeferred.promise;
	};
	var timeout;
	if(typeof setTimeout !== "undefined") {
		this.timeout = function (ms) {
			if (ms === undefined) {
				return timeout;
			}
			timeout = ms;
			setTimeout(function () {
				if (!finished) {
					if (promise.cancel) {
						promise.cancel(new Error("timeout"));
					}
					else {
						reject(new Error("timeout"));
					}
				}
			}, ms);
			return promise;
		};
	}
	
	if(canceller){
		this.cancel = promise.cancel = function(){
			var error = canceller();
			if(!(error instanceof Error)){
				error = new Error(error);
			}
			reject(error);
		}
	}
	freeze(promise);
};

function perform(value, async, sync){
	try{
		if(value && typeof value.then === "function"){
			value = async(value);
		}
		else{
			value = sync(value);
		}
		if(value && typeof value.then === "function"){
			return value;
		}
		var deferred = new Deferred();
		deferred.resolve(value);
		return deferred.promise;
	}catch(e){
		var deferred = new Deferred();
		deferred.reject(e);
		return deferred.promise;
	}
	
}
/**
 * Promise manager to make it easier to consume promises
 */

function rethrow(err){ throw err; }
 
/**
 * Registers an observer on a promise, always returning a promise
 * @param value		 promise or value to observe
 * @param resolvedCallback function to be called with the resolved value
 * @param rejectCallback	function to be called with the rejection reason
 * @param progressCallback	function to be called when progress is made
 * @return promise for the return value from the invoked callback
 */
exports.whenPromise = function(value, resolvedCallback, rejectCallback, progressCallback){
	var deferred = defer();
	if(value && typeof value.then === "function"){
		value.then(function(next){
			deferred.resolve(next);
		},function(error){
			deferred.reject(error);
		});
		rejectCallback = rejectCallback || rethrow;
	}else{
		deferred.resolve(value);
	}
	return deferred.promise.then(resolvedCallback, rejectCallback, progressCallback);
};

/**
 * Registers an observer on a promise.
 * @param value		 promise or value to observe
 * @param resolvedCallback function to be called with the resolved value
 * @param rejectCallback	function to be called with the rejection reason
 * @param progressCallback	function to be called when progress is made
 * @return promise for the return value from the invoked callback or the value if it
 * is a non-promise value
 */
exports.when = function(value, resolvedCallback, rejectCallback, progressCallback){
		if(value && typeof value.then === "function"){
				if(value instanceof Promise){
						return value.then(resolvedCallback, rejectCallback, progressCallback);
				}
				else{
						return exports.whenPromise(value, resolvedCallback, rejectCallback, progressCallback);
				}
		}
		return resolvedCallback ? resolvedCallback(value) : value;
};

/**
 * This is convenience function for catching synchronously and asynchronously thrown
 * errors. This is used like when() except you execute the initial action in a callback:
 * whenCall(function(){
 *   return doSomethingThatMayReturnAPromise();
 * }, successHandler, errorHandler);
 */
exports.whenCall = function(initialCallback, resolvedCallback, rejectCallback, progressCallback){
	try{
		return exports.when(initialCallback(), resolvedCallback, rejectCallback, progressCallback);
	}catch(e){
		return rejectCallback(e);
	}
}

/**
 * Gets the value of a property in a future turn.
 * @param target	promise or value for target object
 * @param property		name of property to get
 * @return promise for the property value
 */
exports.get = function(target, property){
	return perform(target, function(target){
		return target.get(property);
	},
	function(target){
		return target[property]
	});
};

/**
 * Invokes a method in a future turn.
 * @param target	promise or value for target object
 * @param methodName		name of method to invoke
 * @param args		array of invocation arguments
 * @return promise for the return value
 */
exports.call = function(target, methodName, args){
	return perform(target, function(target){
		return target.call(methodName, args);
	},
	function(target){
		return target[methodName].apply(target, args);
	});
};

/**
 * Sets the value of a property in a future turn.
 * @param target	promise or value for target object
 * @param property		name of property to set
 * @param value	 new value of property
 * @return promise for the return value
 */
exports.put = function(target, property, value){
	return perform(target, function(target){
		return target.put(property, value);
	},
	function(target){
		return target[property] = value;
	});
};


/**
 * Waits for the given promise to finish, blocking (and executing other events)
 * if necessary to wait for the promise to finish. If target is not a promise
 * it will return the target immediately. If the promise results in an reject,
 * that reject will be thrown.
 * @param target	 promise or value to wait for.
 * @return the value of the promise;
 */
var queue;
//try {
//		queue = require("event-loop");
//}
//catch (e) {}
exports.wait = function(target){
	if(!queue){
		throw new Error("Can not wait, the event-queue module is not available");
	}
	if(target && typeof target.then === "function"){
		var isFinished, isError, result;		
		target.then(function(value){
			isFinished = true;
			result = value;
		},
		function(error){
			isFinished = true;
			isError = true;
			result = error;
		});
		while(!isFinished){
			queue.processNextEvent(true);
		}
		if(isError){
			throw result;
		}
		return result;
	}
	else{
		return target;
	}
};



/**
 * Takes an array of promises and returns a promise that is fulfilled once all
 * the promises in the array are fulfilled
 * @param array	The array of promises
 * @return the promise that is fulfilled when all the array is fulfilled, resolved to the array of results
 */
exports.all = function(array){
	var deferred = new Deferred();
	if(!(array instanceof Array)){
		array = Array.prototype.slice.call(arguments);
	}
	var fulfilled = 0, length = array.length;
	var results = [];
	if (length === 0) deferred.resolve(results);
	else {	
		array.forEach(function(promise, index){
			exports.when(promise, 
				function(value){
					results[index] = value;
					fulfilled++;
					if(fulfilled === length){
						deferred.resolve(results);
					}
				},
				deferred.reject);
		});
	}
	return deferred.promise;
};

/**
 * Takes a hash of promises and returns a promise that is fulfilled once all
 * the promises in the hash keys are fulfilled
 * @param hash	The hash of promises
 * @return the promise that is fulfilled when all the hash keys is fulfilled, resolved to the hash of results
 */
exports.allKeys = function(hash){
	var deferred = new Deferred();
	var array = Object.keys(hash);
	var fulfilled = 0, length = array.length;
	var results = {};
	if (length === 0) deferred.resolve(results);
	else {
		array.forEach(function(key){
			exports.when(hash[key],
				function(value){
					results[key] = value;
					fulfilled++;
					if(fulfilled === length){
						deferred.resolve(results);
					}
				},
				deferred.reject);
		});
	}
	return deferred.promise;
};

/**
 * Takes an array of promises and returns a promise that is fulfilled when the first 
 * promise in the array of promises is fulfilled
 * @param array	The array of promises
 * @return a promise that is fulfilled with the value of the value of first promise to be fulfilled
 */
exports.first = function(array){
	var deferred = new Deferred();
	if(!(array instanceof Array)){
		array = Array.prototype.slice.call(arguments);
	}
	var fulfilled;
	array.forEach(function(promise, index){
		exports.when(promise, function(value){
			if (!fulfilled) {
				fulfilled = true;
				deferred.resolve(value);
			}	
		},
		function(error){
			if (!fulfilled) {
				fulfilled = true;
				deferred.resolve(error);
			}	
		});
	});
	return deferred.promise;
};

/**
 * Takes an array of asynchronous functions (that return promises) and 
 * executes them sequentially. Each funtion is called with the return value of the last function
 * @param array	The array of function
 * @param startingValue The value to pass to the first function
 * @return the value returned from the last function
 */
exports.seq = function(array, startingValue){
	array = array.concat(); // make a copy
	var deferred = new Deferred();
	function next(value){
		var nextAction = array.shift();
		if(nextAction){
			exports.when(nextAction(value), next, deferred.reject);
		}
		else {
			deferred.resolve(value);
		}	
	}
	next(startingValue);
	return deferred.promise;
};


/**
 * Delays for a given amount of time and then fulfills the returned promise.
 * @param milliseconds The number of milliseconds to delay
 * @return A promise that will be fulfilled after the delay
 */
if(typeof setTimeout !== "undefined") {
	exports.delay = function(milliseconds) {
		var deferred = new Deferred();
		setTimeout(function(){
			deferred.resolve();
		}, milliseconds);
		return deferred.promise;
	};
}



/**
 * Runs a function that takes a callback, but returns a Promise instead.
 * @param func	 node compatible async function which takes a callback as its last argument
 * @return promise for the return value from the callback from the function
 */
exports.execute = function(asyncFunction){
	var args = Array.prototype.slice.call(arguments, 1);

	var deferred = new Deferred();
	args.push(function(error, result){
		if(error) {
			deferred.emitError(error);
		}
		else {
			if(arguments.length > 2){
				// if there are multiple success values, we return an array
				Array.prototype.shift.call(arguments, 1);
				deferred.emitSuccess(arguments);
			}
			else{
				deferred.emitSuccess(result);
			}
		}
	});
	asyncFunction.apply(this, args);
	return deferred.promise;
};

/**
 * Converts a Node async function to a promise returning function
 * @param func	 node compatible async function which takes a callback as its last argument
 * @return A function that returns a promise
 */
exports.convertNodeAsyncFunction = function(asyncFunction, callbackNotDeclared){
	var arity = asyncFunction.length;
	return function(){
		var deferred = new Deferred();
		if(callbackNotDeclared){
			arity = arguments.length + 1;
		}
		arguments.length = arity;
		arguments[arity - 1] = function(error, result){
			if(error) {
				deferred.emitError(error);
			}
			else {
				if(arguments.length > 2){
					// if there are multiple success values, we return an array
					Array.prototype.shift.call(arguments, 1);
					deferred.emitSuccess(arguments);
				}
				else{
					deferred.emitSuccess(result);
				}
			}
		};
		asyncFunction.apply(this, arguments);
		return deferred.promise;
	};
};
});
})(typeof define!="undefined"?define:function(factory){factory(require,exports)});
define('litmus',["require","exports","module","./lib/assertions","./lib/utils","promised-io/promise"],function(require,exports,module){/**
 * @fileoverview This file contains the main implementation of the Litmus JavaScript
 *               unit testing framework. Including just this file should be enough
 *               to write most basic unit tests.
 *
 * @author Thomas Yandell
 */

var promise    = require('promised-io/promise'),
    utils      = require('./lib/utils'),
    assertions = require('./lib/assertions');

/**
 * @namespace Classes for writing, running and formatting the results of tests and
 *            suites of tests.
 */

/**
 * @private
 * @constructor The result of running a litmus.Suite. An instance of this class is
 *              the invocant of the callback that is passed to the `Suite.run` method.
 * 
 * @param {litmus.Suite} suite
 *   The test suite that this is the result of.
 */

var SuiteRun = exports.SuiteRun = function (suite) {
    this.suite = suite;
    this.finished = new promise.Promise();
    var run = this;
    this.finished.then(function (runs) {
        run.runs = runs;
        run.failed = ! (run.passed = runs.every(function (run) {
            return run.passed;
        }));
        run._fireEvent('finish');
    });
};

utils.makeEventEmitter(SuiteRun);

/**
 * @method Starts the suite running.
 */

SuiteRun.prototype.start = function () {
    var finished = [],
        run = this;
    // TODO check this
    all(
        this.suite.tests.map(function (test) {
            var run = test.createRun();
            run.start();
            return run;
        })
    ).then(function (runs) {
        promise.when(
            all(runs.map(function (run) { return run.finished; })),
            function () {
                run.finished.resolve(runs);
            }
        );
    });
};

function _moduleName (module) {
    var name = module.id || module;
    if (process && process.cwd) {
        var cwd  = process.cwd()
        if (name.indexOf(cwd) == 0) {
            name = name.substr(cwd.length + 1);
        }
    }
    return name;
}

/**
 * @constructor Collection of tests.
 *
 * @param {object} module
 *   The module for the test suite.
 * @param {Array of litmus.Test and litmus.Suite objects} tests
 *   The tests that make up the suite.
 */

var Suite = exports.Suite = function (module, tests) {
    this.name = _moduleName(module);
    this.tests = tests;
    if (typeof tests === 'undefined') {
        throw new Error('no tests passed to new litmus.Suite(name, tests) - missing module?');
    }
    if (typeof tests.length === 'undefined') {
        throw new Error('tests passed to new litmus.Suite(name, tests) not array');
    }
    for (var i = 0, l = tests.length; i < l; i++) {
        if (! tests[i]) {
            throw new Error('litmus: test ' +
                i +
                ' passed to new litmus.Suite() undefined'
            );
        }
        else if (! (tests[i] instanceof Suite || tests[i] instanceof Test)) {
            throw new Error('litmus: test ' +
                i +
                ' passed to new litmus.Suite() not litmus.Test or litmus.Suite'
            );
        }
    }
    // TODO - why slice? Add explanation
    this.tests = tests.slice();

};

/**
 * @method Create and reutrn a new SuiteRun for this suite.
 */

Suite.prototype.createRun = function () {
    return new SuiteRun(this);
};

/**
 * @private
 * @method Get an iterator function for getting tests in the suite.
 *
 * @returns A function that returns a litmus.Test each time it is called until there are no
 *          more left in the suite.
 */

Suite.prototype.testIterator = function () {
    var i = 0, subIterator, that = this;
    return function () {
        var test;
        if (subIterator && (test = subIterator()))
            return test;
        if (i >= that.tests.length) return;
        test = that.tests[i++];
        if (test instanceof Test) return test;
        subIterator = test.testIterator();
        return arguments.callee();
    };
};

/**
 * @private
 * @constructor A diagnostic message.
 *
 * @param {String} text
 *   The text of the diagnostic.
 */

var Diagnostic = exports.Diagnostic = function (text) {
    this.text = text;
};

/**
 * @private
 * @constructor A number of assertions that are skipped during a test.
 *
 * @param {String} reason
 *   Why the assertions were skipped.
 * @param {integer} assertions
 *   The number of assertions that were skipped.
 */

var SkippedAssertions = exports.SkippedAssertions = function (reason, assertions) {
    this.skipped = assertions;
    this.reason = reason;
};

/**
 * @private
 * @name TestRun
 * @constructor The result of running a test. TestRuns are not constructed explicitly by
 *              user's code (the constructor so they can't be) but are used as the invocant
 *              for a test's run function. The run function for the test then uses the
 *              TestRun to add assertions to.
 *
 * @param {Test} test
 *   The Test that this is a result for.
 * @param {Function} onfinish
 *   A callback that will be invoked when the test is finished and the result ready.
 */

var notStartedState = 1,
    runningState    = 2,
    finishedState   = 3;

var TestRun = function (test) {
    this.test          = test;
    this.events        = [];
    this.asyncPromises = [];
    this.exceptions    = [];
    this.finished      = new promise.Promise();
    this.state         = notStartedState;
};

utils.makeEventEmitter(TestRun);

// the trouble with promised-io's all method is that it's failure modes are hard to handle
// it seems to reject a promise more than once when faced with more than one failure
// TODO propose these semantics to Kris Zyp
function all (promises) {

    var done      = new promise.Promise,
        successes = [],
        failures  = [],
        failed    = false,
        completed = 0,
        total     = promises.length;

    if (promises.length === 0) {
        done.resolve([]);
        return done;
    }

    var check = function () {
        if (++completed < total) {
            return;
        }
        if (failures.length) {
            failures.successes = successes;
            done.reject(failures);
        }
        else {
            done.resolve(successes);
        }
    };

    for (var i = 0; i < total; i++) {
        promise.when(promises[i], function (result) {
            successes[i] = result;
            check();
        }, function (error) {
            failures[i] = error;
            check();
        });
    }

    return done;
}


/**
 * @method Runs the test running with the TestRun as the invocant.
 */

TestRun.prototype.start = function () {
    this.state = runningState;
    var run = this;
    this._fireEvent('start');
    try {
        this.test.runFunc.call(this);
    }
    catch (e) {
        var location = (e.fileName ? ' at ' + e.fileName + ' line ' + e.lineNumber : '');
        new Error('error in "' + this.test.name + '" test - ' + (e.message || e) + location + (e.stack ? '\n' + e.stack : ''));
        this.addException(new Error('error in "' + this.test.name + '" test - ' + (e.message || e) + location + (e.stack ? '\n' + e.stack : '')));
    }
    all(this.asyncPromises).then(function (results) {
        if (! run.plannedAssertionsRan()) {
            run.failed = true;
        }
        else if (! run.failed) {
            run.failed = false;
            run.passed = true;
        }
        run.state = finishedState;
        run.finished.resolve();
    }, function (err) {
        for (var i = 0, l = err.length; i < l; i++) {
            if (typeof(err[i]) !== 'undefined') {
                run.addException(err[i]);
            }
        }
        run.failed = true;
        run.state = finishedState;
        run.finished.resolve();
    });
};

TestRun.prototype._failRun = function (reason) {
    this.passed = false;
    this.failed = true;
    this._fireEvent('fail', reason);
};

/**
 * @method Check the test is running and throw an appropriate exception otherwise.
 *
 * @param {string} what
 *   The thing being set/added to the test run.
 */

TestRun.prototype._checkRunning = function (eventType, event) {
    if (this.state === notStartedState) {
        throw new Error(eventType + '(' + event + ') added to test run before it was started');
    }
    else if (this.state === finishedState) {
        throw new Error(eventType + ' (' + event + ') added to test run after it was finished');
    }
};

/**
 * @method Set an exception caught running the test.
 *
 * @param {object} exception
 *   The exception that was caught.
 */

TestRun.prototype.addException = function (exception) {
    this._checkRunning('exception (' + (exception.message || exception) + ')');
    this.exceptions.push(exception);
    this._failRun(exception);
};

/**
 * @method Set the expected number of assertions that will be run in this test.
 *
 * @param {integer} assertions
 *   The number of assertions expected.
 */

TestRun.prototype.plan = function (assertions) {
    this._checkRunning('plan');
    this._fireEvent('plan', { 'assertions' : assertions });
    this.planned = assertions;
};

/**
 * @method Add a diagnostic message to the result.
 *
 * @param {String} text
 *   The text of the diagnostic message.
 */

TestRun.prototype.diag = function (text) {
    this._checkRunning('diagnostic');
    this.events.push(new Diagnostic(text));
};

/**
 * @method Skip a number of tests if a condition is met. This is mainly used to not run tests
 *         on environments that do not support specific features.
 *
 * @param {boolean} cond
 *   Assertions are skipped if true.
 * @param {String} reason
 *   Description why the tests are being skipped.
 * @param {integer} skipped
 *    The number of assertions being skipped - must match the number of assertions executed by
 *    the func parameter.
 * @param {Function} func
 *   Function that contains the assertions that may be skipped. This is only called if the cond parameter
 *   is true and is called with the TestRun as it's invocant.
 */

TestRun.prototype.skipif = function (cond, reason, skipped, tests) {
    this._checkRunning('skipped assertions');
    if (cond) {
        this.events.push(new SkippedAssertions(reason, skipped));
    }
    else {
        tests.call(this);
    }
};

/**
 * @method Run tests inside an anonymous function asynchronously. Use either this method or startAsync.
 *
 * @param {String} desc
 *   An identifier for the async execution, so that if end is not called on the handle supplied to the
 *   passed function via the handle parameter, the offending async tests can be found.
 * @param {Function} func
 *   A function that is invoked on the test result (i.e. you can run assertions by calling methods on
 *   this) and is passed an async handle as it's first parameter. The end method should be called on this
 *   handle when the async tests have finished.
 *
 * @returns The return value from the passed in function.
 */

TestRun.prototype.async = function (desc, options, callback) {
    if (typeof(desc) !== 'string') {
        throw new Error('desc prarameter to async method must be a string (' + typeof(desc) + ' found)');
    }
    if (typeof(options) === 'function') {
        callback = options;
        options  = {};
    }

    if (typeof(options.timeout) === 'undefined') {
        options.timeout = 4000;
    }

    this._checkRunning('asynchronous section');

    var done = new promise.Promise(),
        run  = this;

    if (options.timeout > 0) {
        var timeout = setTimeout(function () {
            done.reject(new Error('async operation "' + desc + '" timed out after ' + options.timeout + 'ms'));
        }, options.timeout);

        done.then(function () {
            clearTimeout(timeout);
        }, function (err) {
            clearTimeout(timeout);
        });
    }

    this.asyncPromises.push(done);

    var runner = function () {
        callback.call(run, done);
    };

    // Firefox 6 silently fails when trying to check for process.
    try {
        var nextTick = process.nextTick;
    }
    catch (e) {
        var nextTick = function (runner) {
            setTimeout(runner, 0);    
        }            
    }

    nextTick(runner);
};

/**
 * @private
 * @method Get assertions that have been run.
 *
 * @returns An array of Assertion objects.
 */

TestRun.prototype.assertions = function () {
    var assertions = [];
    for (var i = 0, l = this.events.length; i < l; i++) {
        if (this.events[i].isAssertion) {
            assertions.push(this.events[i]);
        }
    }
    return assertions;
};

/**
 * @private
 * @method Get skipped assertions
 *
 * @returns An array of SkippedAssertions objects.
 */

TestRun.prototype.skippedAssertions = function () {
    var skippedAssertions = [];
    for (var i = 0, l = this.events.length; i < l; i++) {
        if (this.events[i] instanceof SkippedAssertions) {
            skippedAssertions.push(this.events[i]);
        }
    }
    return skippedAssertions;
};

/**
 * @private
 * @method Get the number of assertions that have been skipped.
 *
 * @returns The number of skipped assertions.
 */

TestRun.prototype.assertionsSkipped = function () {
    var skippedAssertions = this.skippedAssertions(),
        total = 0;
    for (var i = 0, l = skippedAssertions.length; i < l; i++) {
        total += skippedAssertions[i].skipped;
    }
    return total;
};

/**
 * @private
 * @method Check if the number of assertions ran and skipped are the same as those planned.
 *
 * @returns Boolean, true if the correct number of assertions ran.
 */

TestRun.prototype.plannedAssertionsRan = function () {
    return typeof(this.planned) === 'undefined' ||
           this.planned === (this.assertionsSkipped() + this.assertions().length);
};

/**
 * @private 
 * @method Get the number of assertions that passed.
 *
 * @returns Number of assertions that passed.
 */

TestRun.prototype.passes = function () {
    var total = 0;
    var assertions = this.assertions();
    for (var i = 0, l = assertions.length; i < l; i++) {
        if (assertions[i].passed) total++;
    }
    return total;
};

/**
 * @private
 * @method Get the number of assertions that failed.
 *
 * @returns Number of assertions that failed.
 */

TestRun.prototype.fails = function () {
    var total = 0;
    var assertions = this.assertions();
    for (var i = 0, l = assertions.length; i < l; i++) {
        if (assertions[i].failed) total++;
    }
    return total;
};

/**
 * @private
 * @method Add an assertion to the result's events.
 *
 * @param {Assertion} assertion
 *   The assertion event to add.
 *
 * @returns Boolean, true if the assertion passed.
 */

TestRun.prototype.addAssertion = function (assertion) {
    this._checkRunning('assertion', assertion);
    this.events.push(assertion);
    if (! assertion.passed) {
        this._failRun(assertion);
    }
    return assertion.passed;
};

function mixinAssertionType (proto, name, AssertionType) {
    proto[name] = function () {
        var assertion = new AssertionType(),
            result    = assertion.run.apply(assertion, arguments);
        this.addAssertion(assertion);
        return result;
    };
}

for (var name in assertions.builtins) {
    mixinAssertionType(TestRun.prototype, name, assertions.builtins[name]);
}

/**
 * @constructor A named collection of assertions for testing an area of functionality.
 *
 * @param {object} module
 *   The module for the test.
 * @param {Function} runFunc
 *   The function performs the testing. This is called as a result of calling the run method and is
 *   invoked with a TestRun object as it's invocant, which has methods to test assertions.
 */

var Test = exports.Test = function (module, runFunc) {
    this.name = _moduleName(module);
    this.runFunc = runFunc;
};

/**
 * @method Creates and returns a new TestRun for this test.
 */
Test.prototype.createRun = function () {
    return new TestRun(this);
};


});
define('lib/formatting',["require","exports","module","../litmus","./utils"],function(require,exports,module){
var litmus = require('../litmus'),
    utils  = require('./utils');

/**
 * @function Escape the entities in a string and return the result.
 * @param {String} html
 *     The string to be escaped.
 * @returns: The input string with the entities escaped.
 */

escapeHtml = function (html) {
    if (! html) {
        return "";
    }

    // FIXME added some crazy comment markers to fix bug in amdtools conversion
    return html.toString().replace(/([&<>"/*"*/])/g, function (character) { //"
       
        return '&' + (
            character === '&' ? 'amp' :
            character === '<' ? 'lt' :
            character === '>' ? 'gt' : 'quot'
        ) + ';';
    });
}

/**
 * @private
 * @abstract
 * @constructor Abstract base class for formatters of SuiteRuns and TestRuns.
 */

var Formatter = function () {};

/**
 * @abstract
 * @extends Formatter
 * @constructor Abstract base class for static formatters of SuiteRuns and TestRuns. Static
 *              formatters are run on SuiteRuns and TestRuns that are complete - i.e. they
 *              create linear output.
 */

var StaticFormatter = exports.StaticFormatter = function () {
    arguments.callee.base.apply(this, arguments);
};
utils.extend(StaticFormatter, Formatter);

/**
 * @method Format a SuiteRun or TestRun by defering to formatSuite or formatTest methods.
 *
 * @param {Array} r
 *   Buffer for collecting output.
 * @param {TestRun|SuiteRun} res
 *   The result to format.
 */

StaticFormatter.prototype.formatSuiteOrTest = function (r, res) {
    if (res instanceof litmus.SuiteRun) {
        this.formatSuite(r, res);
    }
    else {
        this.formatTest(r, res);
    }
};

/**
 * @method Formats each of the sub-results in the passed in SuiteRun.
 *
 * @param {Array} buffer
 *   Buffer for collecting output.
 * @param {SuiteRun} res
 *   The SuiteRun to format.
 */

StaticFormatter.prototype.formatSuite = function (buffer, run) {
    for (var i = 0, l = run.runs.length; i < l; i++) {
        this.formatSuiteOrTest(buffer, run.runs[i]);
    }
};

/**
 * @extends extends Static
 * @constructor HTML formatter for finished TestRuns and SuiteRuns.
 */

StaticHtmlFormatter = exports.StaticHtmlFormatter = function () {
    arguments.callee.base.apply(this, arguments);
};
utils.extend(StaticHtmlFormatter, StaticFormatter);

/**
 * @method Get the passed in TestRun or SuiteRun formatted as html.
 *
 * @param {TestRun|SuiteRun} res
 *   The result to be formatted.
 *
 * @returns String - the formatted html.
 */

StaticHtmlFormatter.prototype.format = function (res) {
    var r = [];
    r.push(
        '<div class="slouch-result">',
        '<h1>Litmus Test Result</h1>',
        '<p>Result: <span>',
        res.passed ? 'PASS' : 'FAIL',
        '</span></p></div>'
    );

    this.formatSuiteOrTest(r, res);

    return r.join('');
};

/**
 * @private
 * @method Get passed in TestRun formatted as html.
 *
 * @param {Array} r
 *   Buffer for collecting output.
 * @param {TestRun} res
 *   The TestRun to format.
 */

StaticHtmlFormatter.prototype.formatTest = function (r, res) {
    r.push(
        '<div class="litmus-test-result">',
        '<h2>', escapeHtml(res.test.name), '</h2>'
    );
    if (res.error) {
        r.push('<p class="error">An exception was encountered while running the test. See below.</p>');
    }

    if (res.plannedAssertionsRan()) {
        r.push('<p class="count">Assertions: ', res.assertions().length, '</p>');
    }
    else {
        r.push(
            '<p class="count-error">',
            'Assertions count error. Planned ',
            escapeHtml(res.planned),
            ' assertions, but ran ',
            res.assertions().length,
            '.</p>'
        );
    }
    r.push(
        '<p>Assertions: ',
        res.passes(),
        ' passed, ',
        res.fails(),
        ' failed.</p><ul class="assertions">'
    );
    for (var i = 0, l = res.events.length; i < l; i++) {
        var event = res.events[i];
        if (event instanceof litmus.Diagnostic) {
            r.push('<li class="diagnostic">', escapeHtml(event.text), '</li>');
        }
        else if (event instanceof litmus.SkippedAssertions) {
            r.push(
                '<li class="assertions-skipped"><span class="status">[ SKIPPED ]</span>  ',
                escapeHtml(event.skipped),
                ' assertions skipped - ',
                escapeHtml(event.reason),
                '</li>'
            );
        }
        else {
            r.push(
                '<li class="',
                event.passed ? 'assertion-pass' : 'assertion-fail',
                '"><span class="status">[ ',
                event.passed ? 'PASS' : 'FAIL',
                ' ]</span> ', escapeHtml(event.message),
                event.extra ? [
                    ' - <span class="extra">',
                    escapeHtml(event.extra),
                    '</span>'
                ].join('') : '',
                '</li>'
            );
        }
    }
    if (res.error) {
        r.push('<li class="assertion-error"><span class="status">[ ERROR ]</span> ', escapeHtml(res.error), '</li>');
    }
    r.push('</ul></div>');
};

/**
 * @extends Static
 * @constructor Plain text formatter for finished TestRuns and SuiteRuns.
 */

var StaticTextFormatter = exports.StaticTextFormatter = function () {
    arguments.callee.base.apply(this, arguments);
};
utils.extend(StaticTextFormatter, StaticFormatter);

/**
 * @method Get the passed in TestRun or SuiteRun formatted as plain text.
 *
 * @param {TestRun|SuiteRun} run
 *   The suite or test run to be formatted.
 *
 * @returns String - the formatted plain text.
 */

StaticTextFormatter.prototype.format = function (run) {
    var buffer = [];
    buffer.push(
        'Litmus Test Result\n',
        '==================\n\n',
        'Result: ',
        setColour(run.passed ? 'green' : 'red'),
        run.passed ? 'PASS' : 'FAIL',
        unsetColour(),
        '\n\n'
    );

    this.formatSuiteOrTest(buffer, run);

    buffer.push(
        'Summary\n',
        '=======\n\nResult:\n    ',
        setColour(run.passed ? 'green' : 'red'),
        run.passed ? 'PASS' : 'FAIL',
        '\n\n',
        unsetColour()
    );

    return buffer.join('');
};

function setColour (colour) {
    var colours = {
        'red'       : 31,
        'green'     : 32,
        'yellow'    : 33,
        'blue'      : 34,
        'magenta'   : 35,
        'cyan'      : 36
    };
    if (! colours[colour]) {
        throw new Error('unknown colour ' + colour);
    }
    return '\033[' + colours[colour] + 'm';
}

function unsetColour () {
    return '\033[39m';
}

/**
 * @private
 * @method Get passed in TestRun formatted as plain text.
 *
 * @param {Array} buffer
 *   Buffer for collecting output.
 * @param {TestRun} run
 *   The TestRun to format.
 */

StaticTextFormatter.prototype.formatTest = function (buffer, run) {
    buffer.push(
        run.test.name, '\n',
        utils.times('-', run.test.name.length), '\n\n'
    );
    if (! run.plannedAssertionsRan()) {
        buffer.push(
            setColour('red'),
            '[ ERROR ] Planned ',
            run.planned,
            ' assertion' + (run.planned === 1 ? '' : 's') + ' but ',
            run.assertions().length,
            ' were encountered',
            unsetColour(),
            '\n\n'
        );
    }
    buffer.push(
        setColour('yellow'),
        '[ INFO ] Assertions: ',
        run.passes(),
        ' passed, ',
        run.fails(),
        ' failed',
        unsetColour(),
        '\n'
    );
    if (run.events.length) {
        buffer.push('\n');
    }
    for (var i = 0, l = run.events.length; i < l; i++) {
        var event = run.events[i];
        if (event instanceof litmus.Diagnostic) {
            buffer.push(
                '# ', event.text, '\n'
            );
        }
        else if (event instanceof litmus.SkippedAssertions) {
            buffer.push(
                setColour('cyan'),
                '[ SKIPPED ] ',
                event.skipped,
                ' assertions skipped - ',
                event.reason,
                unsetColour(),
                '\n'
            );
        }
        else {
            buffer.push(
                setColour(event.passed ? 'green' : 'red'),
                '[ ',
                    event.passed ? 'PASS' : 'FAIL',
                ' ] ',
                event.message,
                event.extra ? ' (' + event.extra + ')' : '',
                unsetColour(),
                '\n'
            );
        }
    }
    for (var i = 0, l = run.exceptions.length; i < l; i++) {
        buffer.push('\n' + setColour('red') + '[ ERROR ] ', run.exceptions[i].message || run.exceptions[i], unsetColour(), '\n');
    }
    buffer.push('\n');
};



});
/**
 * @license RequireJS domReady 1.0.0 Copyright (c) 2010-2011, The Dojo Foundation All Rights Reserved.
 * Available via the MIT or new BSD license.
 * see: http://github.com/jrburke/requirejs for details
 */
/*jslint strict: false, plusplus: false */
/*global require: false, define: false, requirejs: false,
  window: false, clearInterval: false, document: false,
  self: false, setInterval: false */


define('domReady',[],function () {
    var isBrowser = typeof window !== "undefined" && window.document,
        isPageLoaded = !isBrowser,
        doc = isBrowser ? document : null,
        readyCalls = [],
        readyLoaderCalls = [],
        //Bind to a specific implementation, but if not there, try a
        //a generic one under the "require" name.
        req = requirejs || require || {},
        oldResourcesReady = req.resourcesReady,
        scrollIntervalId;

    function runCallbacks(callbacks) {
        for (var i = 0, callback; (callback = callbacks[i]); i++) {
            callback(doc);
        }
    }

    function callReady() {
        var callbacks = readyCalls,
            loaderCallbacks = readyLoaderCalls;

        if (isPageLoaded) {
            //Call the DOM ready callbacks
            if (callbacks.length) {
                readyCalls = [];
                runCallbacks(callbacks);
            }

            //Now handle DOM ready + loader ready callbacks.
            if (req.resourcesDone && loaderCallbacks.length) {
                readyLoaderCalls = [];
                runCallbacks(loaderCallbacks);
            }
        }
    }

    /**
     * Add a method to require to get callbacks if there are loader resources still
     * being loaded. If so, then hold off calling "withResources" callbacks.
     *
     * @param {Boolean} isReady: pass true if all resources have been loaded.
     */
    if ('resourcesReady' in req) {
        req.resourcesReady = function (isReady) {
            //Call the old function if it is around.
            if (oldResourcesReady) {
                oldResourcesReady(isReady);
            }

            if (isReady) {
                callReady();
            }
        };
    }

    /**
     * Sets the page as loaded.
     */
    function pageLoaded() {
        if (!isPageLoaded) {
            isPageLoaded = true;
            if (scrollIntervalId) {
                clearInterval(scrollIntervalId);
            }

            callReady();
        }
    }

    if (isBrowser) {
        if (document.addEventListener) {
            //Standards. Hooray! Assumption here that if standards based,
            //it knows about DOMContentLoaded.
            document.addEventListener("DOMContentLoaded", pageLoaded, false);
            window.addEventListener("load", pageLoaded, false);
        } else if (window.attachEvent) {
            window.attachEvent("onload", pageLoaded);

            //DOMContentLoaded approximation, as found by Diego Perini:
            //http://javascript.nwbox.com/IEContentLoaded/
            if (self === self.top) {
                scrollIntervalId = setInterval(function () {
                    try {
                        //From this ticket:
                        //http://bugs.dojotoolkit.org/ticket/11106,
                        //In IE HTML Application (HTA), such as in a selenium test,
                        //javascript in the iframe can't see anything outside
                        //of it, so self===self.top is true, but the iframe is
                        //not the top window and doScroll will be available
                        //before document.body is set. Test document.body
                        //before trying the doScroll trick.
                        if (document.body) {
                            document.documentElement.doScroll("left");
                            pageLoaded();
                        }
                    } catch (e) {}
                }, 30);
            }
        }

        //Check if document already complete, and if so, just trigger page load
        //listeners.
        if (document.readyState === "complete") {
            pageLoaded();
        }
    }

    /** START OF PUBLIC API **/

    /**
     * Registers a callback for DOM ready. If DOM is already ready, the
     * callback is called immediately.
     * @param {Function} callback
     */
    function domReady(callback) {
        if (isPageLoaded) {
            callback(doc);
        } else {
            readyCalls.push(callback);
        }
        return domReady;
    }

    /**
     * Callback that waits for DOM ready as well as any outstanding
     * loader resources. Useful when there are implicit dependencies.
     * This method should be avoided, and always use explicit
     * dependency resolution, with just regular DOM ready callbacks.
     * The callback passed to this method will be called immediately
     * if the DOM and loader are already ready.
     * @param {Function} callback
     */
    domReady.withResources = function (callback) {
        if (isPageLoaded && req.resourcesDone) {
            callback(doc);
        } else {
            readyLoaderCalls.push(callback);
        }
        return domReady;
    };

    domReady.version = '1.0.0';

    /**
     * Loader Plugin API method
     */
    domReady.load = function (name, req, onLoad, config) {
        if (config.isBuild) {
            onLoad(null);
        } else {
            domReady(onLoad);
        }
    };

    /** END OF PUBLIC API **/

    return domReady;
});

define('litmus/browser',['../litmus', '../lib/formatting', 'domReady'], function (litmus, formatting, domReady) {

   /**
    * Namespace: litmus.browser - Litmus running in a browser
    *
    * Functions for running tests and formatting results in a browser.
    */

    var ns = {};

    var body = document.getElementsByTagName('body')[0];

   /**
    * Private function: addToBody
    *
    * Format a TestResult/SuiteResult and add it to the document body.
    */

    function addToBody (run) {
        var formatter = new formatting.StaticHtmlFormatter();
        var element = document.createElement('div');
        element.setAttribute('class', 'litmus-results');
        element.innerHTML = formatter.format(run);
        document.body.appendChild(element);
    }

   /**
    * Private function: getTests
    *
    * Get an array containing the the Suites and Tests passed on the query or the default.
    *
    * Arguments:
    *   defaultTest - (required string) name of the test package to run.
    *
    * Returns: an array of test package names to run.
    */

    function getTests (defaultTest) {
        if (location.search) {
            var tests = location.search.substr(1).split('&');
            for (var i = 0, l = tests.length; i < l; i++) {
                if (! /^\w+(?:\.\w+)*$/.test(tests[i])) {
                    throw 'invalid package name passed on query string: ' + tests[i];
                }
            }
            return tests;
        }
        else {
            return [defaultTest];
        }
    }

   /**
    * Function: runStatic
    *
    * Run and format the results of suites and tests. The default Suite or Test
    * is passed in and can be overridden by specifying them in the query string
    * separated by &'s. For example, if the page is index.html, then the tests
    * can be specified by loading "index.html?my.test1&my.suite1".
    *
    * Arguments:
    *   defaultTest - (required string) name of the test package to run.
    */

    ns.runStatic = function (defaultTest) {

        var tests = getTests(defaultTest);

        for (var i = 0, l = tests.length; i < l; i++) {
            require([tests[i]], function (test) {
                ns.run(test);
            });
        }
    };

    ns.run = function (test) {
        var run = test.createRun();
        run.finished.then(function () {
            domReady(function () {
                addToBody(run);    
            });
        });
        run.start();
    }

    return ns;
});
